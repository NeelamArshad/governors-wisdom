<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Wisdom and Governors</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="analysis_files/libs/clipboard/clipboard.min.js"></script>
<script src="analysis_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="analysis_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="analysis_files/libs/quarto-html/popper.min.js"></script>
<script src="analysis_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="analysis_files/libs/quarto-html/anchor.min.js"></script>
<link href="analysis_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="analysis_files/libs/quarto-html/quarto-syntax-highlighting-37eea08aefeeee20ff55810ff984fec1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="analysis_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="analysis_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="analysis_files/libs/bootstrap/bootstrap-bb462d781dde1847d9e3ccf7736099dd.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Wisdom and Governors</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<div class="cell">
<div class="cell-output cell-output-stderr">
<pre><code>Warning: package 'purrr' was built under R version 4.5.1</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>Warning: package 'gt' was built under R version 4.5.1</code></pre>
</div>
</div>
<section id="background-information" class="level2">
<h2 class="anchored" data-anchor-id="background-information">Background Information</h2>
<p>This dataset is drawn from an attempt to estimate the causal effect of winning an election on the subsequent lifespan of political candidates. The study includes data from candidates who participated in competitive elections, with the treatment defined as winning versus losing a narrowly decided race. By focusing on close contests, the analysis aims to approximate random assignment, helping to address confounding variables that might otherwise bias estimates. The dataset records each candidate’s age at election, party affiliation, gender, vote margin, and eventual age at death, allowing for regression-based modeling of the relationship between electoral outcomes and longevity.</p>
<p>Commentary: http://www.stat.columbia.edu/~gelman/research/published/causal_paths_3.pdf Response: https://erikgahner.dk/2020/a-response-to-andrew-gelman/</p>
<section id="scenarios" class="level3">
<h3 class="anchored" data-anchor-id="scenarios">Scenarios</h3>
<ol type="1">
<li><p>Imagine you work for a life insurer, and want to forecast how long a newly elected Senator might live based on their age, party, and other variables.</p></li>
<li><p>Imagine you are a researcher. You want to know if winning candidates live longer.</p></li>
</ol>
</section>
<section id="data" class="level3">
<h3 class="anchored" data-anchor-id="data">Data</h3>
<p>For this assignment, we will use the <code>governors</code> dataset, which contains information on U.S. gubernatorial candidates and their election outcomes. This dataset comes from published research and is available in the <code>primer.data</code> package.</p>
<ul>
<li>Explore the data. What is the outcome variable? How is it distributed?</li>
</ul>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 3,587 × 13
   state    year first_name last_name party   sex   died       status win_margin
   &lt;chr&gt;   &lt;int&gt; &lt;chr&gt;      &lt;chr&gt;     &lt;chr&gt;   &lt;chr&gt; &lt;date&gt;     &lt;chr&gt;       &lt;dbl&gt;
 1 Alabama  1851 Henry      Collier   Democr… Male  1855-08-28 Chall…     73.4  
 2 Alabama  1853 John       Winston   Democr… Male  1871-12-21 Chall…     46.1  
 3 Alabama  1855 John       Winston   Democr… Male  1871-12-21 Chall…     15.6  
 4 Alabama  1857 Andrew     Moore     Democr… Male  1873-04-05 Chall…    100    
 5 Alabama  1859 Andrew     Moore     Democr… Male  1873-04-05 Chall…     45.6  
 6 Alabama  1861 John       Shorter   Democr… Male  1872-05-29 Chall…     15.2  
 7 Alabama  1863 John       Shorter   Democr… Male  1872-05-29 Chall…    -49.0  
 8 Alabama  1868 William    Smith     Republ… Male  1899-01-01 Chall…    100    
 9 Alabama  1870 Robert     Lindsay   Democr… Male  1902-02-13 Chall…      0.936
10 Alabama  1870 William    Smith     Republ… Male  1899-01-01 Chall…     -0.936
# ℹ 3,577 more rows
# ℹ 4 more variables: region &lt;chr&gt;, election_age &lt;dbl&gt;, death_age &lt;dbl&gt;,
#   lived_after &lt;dbl&gt;</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Rows: 3,587
Columns: 13
$ state        &lt;chr&gt; "Alabama", "Alabama", "Alabama", "Alabama", "Alabama", "A…
$ year         &lt;int&gt; 1851, 1853, 1855, 1857, 1859, 1861, 1863, 1868, 1870, 187…
$ first_name   &lt;chr&gt; "Henry", "John", "John", "Andrew", "Andrew", "John", "Joh…
$ last_name    &lt;chr&gt; "Collier", "Winston", "Winston", "Moore", "Moore", "Short…
$ party        &lt;chr&gt; "Democrat", "Democrat", "Democrat", "Democrat", "Democrat…
$ sex          &lt;chr&gt; "Male", "Male", "Male", "Male", "Male", "Male", "Male", "…
$ died         &lt;date&gt; 1855-08-28, 1871-12-21, 1871-12-21, 1873-04-05, 1873-04-…
$ status       &lt;chr&gt; "Challenger", "Challenger", "Challenger", "Challenger", "…
$ win_margin   &lt;dbl&gt; 73.4021143, 46.1124743, 15.5809303, 100.0000000, 45.55431…
$ region       &lt;chr&gt; "South", "South", "South", "South", "South", "South", "So…
$ election_age &lt;dbl&gt; 50.79808, 41.16906, 43.16769, 50.66667, 52.66530, 43.5373…
$ death_age    &lt;dbl&gt; 54.60917, 59.29363, 59.29363, 66.08077, 66.08077, 54.0999…
$ lived_after  &lt;dbl&gt; 3.811088, 18.124572, 16.125941, 15.414100, 13.415469, 10.…</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>    state                year       first_name         last_name        
 Length:3587        Min.   :1850   Length:3587        Length:3587       
 Class :character   1st Qu.:1890   Class :character   Class :character  
 Mode  :character   Median :1922   Mode  :character   Mode  :character  
                    Mean   :1921                                        
                    3rd Qu.:1952                                        
                    Max.   :2011                                        
                                                                        
    party               sex                 died               status         
 Length:3587        Length:3587        Min.   :1675-10-26   Length:3587       
 Class :character   Class :character   1st Qu.:1912-01-04   Class :character  
 Mode  :character   Mode  :character   Median :1945-06-23   Mode  :character  
                                       Mean   :1945-06-14                     
                                       3rd Qu.:1978-09-08                     
                                       Max.   :2019-08-18                     
                                                                              
   win_margin         region           election_age       death_age      
 Min.   :-87.221   Length:3587        Min.   :-158.12   Min.   :-115.99  
 1st Qu.: -7.209   Class :character   1st Qu.:  44.80   1st Qu.:  67.08  
 Median :  2.791   Mode  :character   Median :  50.77   Median :  75.70  
 Mean   :  6.405                      Mean   :  51.19   Mean   :  74.76  
 3rd Qu.: 14.709                      3rd Qu.:  57.01   3rd Qu.:  83.72  
 Max.   :100.000                      Max.   : 274.02   Max.   : 101.72  
 NA's   :1                            NA's   :7         NA's   :7        
  lived_after     
 Min.   :-208.02  
 1st Qu.:  13.52  
 Median :  23.32  
 Mean   :  23.57  
 3rd Qu.:  33.37  
 Max.   :  78.28  
                  </code></pre>
</div>
</div>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="analysis_files/figure-html/unnamed-chunk-2-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="preceptor-table" class="level3">
<h3 class="anchored" data-anchor-id="preceptor-table">Preceptor Table</h3>
<p>What sorts of questions are we trying to answer? Do wining candidates live longer after elections compared to the losing ones?</p>
<p>In order to build the Preceptor Table, we need to know: Is the model causal or predictive? What are units? What are the outcomes? What are the covariates? What are the treatments? Describe the mathematical Structure of the model.</p>
<p>The model is causal. Units are election candidates. Outcome variable is the years lived after. Treatment is wining election or not. Covariates are age, sex and party. The mathematical structure of the model is linear regression.</p>
</section>
<section id="population-table" class="level3">
<h3 class="anchored" data-anchor-id="population-table">Population Table</h3>
<p>Describe the Population Table in your own words—what does each row represent in this context? Then, for each of the four key assumptions (validity, stability, representativeness, and unconfoundedness), provide both a definition in your own words and one specific counter-example for each assumption.</p>
<p>Population table is the unit/time combination e.g., Individuals/at the time of election. Validity is the consistency between columns of the preceptor table. It might not hold as other variable like exercise can be included but not in the preceptor table. Stability is the consistency anong all 3 columns of the preceptor table. It might not hold as over the time people might have lived longer based on better healthcare facilities. Representativeness might not hold as the most of the data is from larger states than the smaller ones. So, it’s not representative of whole population. Unconfoundedness is the assumption that the outcome does not dictate the assignment of the treatment. It might not hold as external factors such as wealth might effect the outcome variable and it is not included in the data.</p>
</section>
<section id="modeling" class="level3">
<h3 class="anchored" data-anchor-id="modeling">Modeling</h3>
<p>The outcome variable in this study is <code>death_age</code>, which is the age each political candidate died. What kind of regression model should you use to predict or explain death_age? Explain your choice based on what kind of variable <code>death_age</code> is?</p>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>
Call:
lm(formula = death_age ~ election_age + year, data = governors)

Coefficients:
 (Intercept)  election_age          year  
  -103.48548       0.29495       0.08493  </code></pre>
</div>
</div>
<p>There is not much correlation between wining the election and years lived after that. We used linear regression because death_age is a continuous dependent variable that we want to predict or explain using other independent variables (like election age and year).</p>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>